diff --git a/fs/isofs/Kconfig b/fs/isofs/Kconfig
index 08ffd37b9bb8..22dcb4ed61dc 100644
--- a/fs/isofs/Kconfig
+++ b/fs/isofs/Kconfig
@@ -38,3 +38,13 @@ config ZISOFS
 	  <http://www.kernel.org/pub/linux/utils/fs/zisofs/> for the tools
 	  necessary to create such a filesystem.  Say Y here if you want to be
 	  able to read such compressed CD-ROMs.
+
+config ZISOFS2
+	bool "Extended support"
+	depends on ZISOFS
+	help
+	  The zisofs2 make possible to handle files bigger than
+	  4 GiB and extend it with more compressors. See
+	  <https://github.com/vk496/zisofs2-tools/> for the tools
+	  necessary to create such a filesystem.  Say Y here if you want to be
+	  able to read such compressed CD-ROMs.
\ No newline at end of file
diff --git a/fs/isofs/compress.c b/fs/isofs/compress.c
index bc12ac7e2312..5893388a296d 100644
--- a/fs/isofs/compress.c
+++ b/fs/isofs/compress.c
@@ -238,12 +238,22 @@ static int zisofs_fill_pages(struct inode *inode, int full_page, int pcount,
 	bh = isofs_bread(inode, blockptr >> blkbits);
 	if (!bh)
 		return -EIO;
-	block_start = le32_to_cpu(*(__le32 *)
-				(bh->b_data + (blockptr & (blksize - 1))));
+
+	if (ISOFS_I(inode)->i_file_format == isofs_file_compressed) {
+		block_start = le32_to_cpu(*(__le32 *)
+					(bh->b_data + (blockptr & (blksize - 1))));
+	} else {
+		block_start = le64_to_cpu(*(__le64 *)
+					(bh->b_data + (blockptr & (blksize - 1))));
+	}
 
 	while (cstart_block < cend_block && pcount > 0) {
 		/* Load end of the compressed block in the file */
-		blockptr += 4;
+		if (ISOFS_I(inode)->i_file_format == isofs_file_compressed) {
+			blockptr += 4;
+		} else {
+			blockptr += 8;
+		}
 		/* Traversed to next block? */
 		if (!(blockptr & (blksize - 1))) {
 			brelse(bh);
@@ -252,8 +262,15 @@ static int zisofs_fill_pages(struct inode *inode, int full_page, int pcount,
 			if (!bh)
 				return -EIO;
 		}
-		block_end = le32_to_cpu(*(__le32 *)
-				(bh->b_data + (blockptr & (blksize - 1))));
+
+		if (ISOFS_I(inode)->i_file_format == isofs_file_compressed) {
+			block_end = le32_to_cpu(*(__le32 *)
+					(bh->b_data + (blockptr & (blksize - 1))));
+		} else {
+			block_end = le64_to_cpu(*(__le64 *)
+					(bh->b_data + (blockptr & (blksize - 1))));
+		}
+
 		if (block_start > block_end) {
 			brelse(bh);
 			return -EIO;
diff --git a/fs/isofs/inode.c b/fs/isofs/inode.c
index 78f5c96c76f3..e2c19ea5c872 100644
--- a/fs/isofs/inode.c
+++ b/fs/isofs/inode.c
@@ -1463,6 +1463,9 @@ static int isofs_read_inode(struct inode *inode, int relocated)
 		inode->i_fop = &generic_ro_fops;
 		switch (ei->i_file_format) {
 #ifdef CONFIG_ZISOFS
+#ifdef CONFIG_ZISOFS2
+		case isofs_file_zisofs2:
+#endif
 		case isofs_file_compressed:
 			inode->i_data.a_ops = &zisofs_aops;
 			break;
diff --git a/fs/isofs/isofs.h b/fs/isofs/isofs.h
index 055ec6c586f7..4078cefcfe20 100644
--- a/fs/isofs/isofs.h
+++ b/fs/isofs/isofs.h
@@ -9,6 +9,7 @@ enum isofs_file_format {
 	isofs_file_normal = 0,
 	isofs_file_sparse = 1,
 	isofs_file_compressed = 2,
+	isofs_file_zisofs2 = 3,
 };
 	
 /*
@@ -107,6 +108,10 @@ static inline unsigned int isonum_733(u8 *p)
 	/* Ignore bigendian datum due to broken mastering programs */
 	return get_unaligned_le32(p);
 }
+static inline unsigned int isonum_uint64(u8 *p)
+{
+	return get_unaligned_le64(p);
+}
 extern int iso_date(u8 *, int);
 
 struct inode;		/* To make gcc happy */
diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c
index 94ef92fe806c..95e841a79c5a 100644
--- a/fs/isofs/rock.c
+++ b/fs/isofs/rock.c
@@ -540,39 +540,46 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,
 			break;
 #ifdef CONFIG_ZISOFS
 		case SIG('Z', 'F'): {
-			int algo;
+			int algo, block_shift;
 
 			if (ISOFS_SB(inode->i_sb)->s_nocompress)
 				break;
 			algo = isonum_721(rr->u.ZF.algorithm);
-			if (algo == SIG('p', 'z')) {
-				int block_shift =
-					isonum_711(&rr->u.ZF.parms[1]);
-				if (block_shift > 17) {
-					printk(KERN_WARNING "isofs: "
-						"Can't handle ZF block "
-						"size of 2^%d\n",
-						block_shift);
-				} else {
-					/*
-					 * Note: we don't change
-					 * i_blocks here
-					 */
-					ISOFS_I(inode)->i_file_format =
-						isofs_file_compressed;
-					/*
-					 * Parameters to compression
-					 * algorithm (header size,
-					 * block size)
-					 */
-					ISOFS_I(inode)->i_format_parm[0] =
-						isonum_711(&rr->u.ZF.parms[0]);
-					ISOFS_I(inode)->i_format_parm[1] =
-						isonum_711(&rr->u.ZF.parms[1]);
-					inode->i_size =
-					    isonum_733(rr->u.ZF.
-						       real_size);
-				}
+			block_shift = isonum_711(&rr->u.ZF.parms[1]);
+
+			if (block_shift > 20 || block_shift < 15) {
+				printk(KERN_WARNING "isofs2: "
+					"Can't handle ZF block "
+					"size of 2^%d\n",
+					block_shift);
+			} else if (algo == SIG('p', 'z')) {
+				/* pz is reserved for zisofs only */
+				/*
+					* Note: we don't change
+					* i_blocks here
+					*/
+				ISOFS_I(inode)->i_file_format =
+					isofs_file_compressed;
+				/*
+					* Parameters to compression
+					* algorithm (header size,
+					* block size)
+					*/
+				ISOFS_I(inode)->i_format_parm[0] =
+					isonum_711(&rr->u.ZF.parms[0]);
+				ISOFS_I(inode)->i_format_parm[1] =
+					block_shift;
+				inode->i_size =
+					isonum_733(rr->u.ZF.
+							real_size);
+#ifdef CONFIG_ZISOFS2
+			} else if (algo == SIG('P', 'Z')) {
+				ISOFS_I(inode)->i_file_format = isofs_file_zisofs2;
+				ISOFS_I(inode)->i_format_parm[0] =
+					isonum_711(&rr->u.ZF.parms[0]);
+				ISOFS_I(inode)->i_format_parm[1] = block_shift;
+				inode->i_size = isonum_uint64(rr->u.ZF.real_size);
+#endif
 			} else {
 				printk(KERN_WARNING
 				       "isofs: Unknown ZF compression "
diff --git a/fs/isofs/rock.h b/fs/isofs/rock.h
index 1558cf22ef8a..9d411d472704 100644
--- a/fs/isofs/rock.h
+++ b/fs/isofs/rock.h
@@ -76,9 +76,9 @@ struct RR_TF_s {
 
 /* Linux-specific extension for transparent decompression */
 struct RR_ZF_s {
-	__u8 algorithm[2];
-	__u8 parms[2];
-	__u8 real_size[8];
+	__u8 algorithm[2]; /* BP 5 - BP 6 */
+	__u8 parms[2]; /* BP 7, BP 8 */
+	__u8 real_size[8]; /* BP 9 - BP 16 */
 };
 
 /*
